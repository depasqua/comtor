/** *  Comment Mentor: A Comment Quality Assessment Tool *  Copyright (C) 2011 The College of New Jersey * *  This program is free software: you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation, either version 3 of the License, or *  (at your option) any later version. * *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. * *  You should have received a copy of the GNU General Public License *  along with this program.  If not, see <http://www.gnu.org/licenses/>. */package org.comtor.analyzers;import org.comtor.reporting.*;import com.sun.javadoc.*;import java.util.*;import java.text.*;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.LogManager;/** * The CommentAvgRatio class is a tool to measure the average length (defined by the number of * words) of comments for all methods and constructors of a class. The "count" of words here, is * number of words the Javadoc comments that (usually) precede the tags (and their comments).  * * @author Joe Brigandi * @author Peter DePasquale */public final class CommentAvgRatio implements ComtorDoclet {	private static Logger logger = LogManager.getLogger(CommentAvgRatio.class.getName());	// Set the initial report object needed for execution. 	private ModuleReport report = null;	// Variables related to scoring	private float minAvgNumWords = 10;	private float maxScore = 5;	// Local variables for metrics information	private int totalNumComments = 0;	private int totalNumWords = 0;	private int totalNumConstructors = 0;	private int totalNumMethods = 0;	private int totalNumFields = 0;	private int numZeroComments = 0;	/**	 * Examine each class and its methods. Calculate the length of each method's comments.	 *	 * @param rootDoc  the root of the documentation tree	 * @return Properties list	 */	public Properties analyze(RootDoc rootDoc) {		logger.entry();		String description = "This module analyzes the length (in terms of the number of words) of class, constructor, " +			"and method comments. The reported score is the ratio of the number of words that comprise " +			"the comments to the overall number of comments.";		report = new ModuleReport("Comment Average Ratio", Util.stringWrapAfter(description, 80));		// Capture the starting time, just prior to the start of the analysis		long startTime = new Date().getTime();		int numClasses = rootDoc.classes().length;		for (ClassDoc classDoc : rootDoc.classes()) {			logger.trace("Processing class '" + classDoc.qualifiedName() + "'");			int numWords = 0;			int numMembers = 0;			report.addItem(ReportItem.CLASS, classDoc.qualifiedName());			report.addLocation(ReportItem.CLASS, classDoc.position());						// Analyze the class			int wordCount = (new StringTokenizer(classDoc.commentText())).countTokens();			if (wordCount != 0) {				report.appendMessage(ReportItem.CLASS_SUMMARY, "There were " + wordCount +						" words in the class comments.");				numMembers++;				numWords += wordCount;				totalNumWords += wordCount;			} else				numZeroComments++;			// Analyze the class constructors			for (ConstructorDoc constr : classDoc.constructors()) {				if (!Util.isNullaryConstructor(constr)) {					report.addItem(ReportItem.CONSTRUCTOR, constr.qualifiedName() + constr.signature());					report.addLocation(ReportItem.CONSTRUCTOR, constr.position());					totalNumConstructors++;					if (constr.commentText().length() != 0)						wordCount = (new StringTokenizer(constr.commentText())).countTokens();					else						wordCount = 0;					numMembers++;					numWords += wordCount;					totalNumWords += wordCount;					if (wordCount != 0)						report.appendMessage(ReportItem.CONSTRUCTOR_SUMMARY, "The length of comments is " + wordCount + " words (on/near line " +							constr.position().line() + ").");					else {						numZeroComments++;						report.appendMessage(ReportItem.CONSTRUCTOR, "There are no Javadoc comments present (on/near line " +							constr.position().line() + ").");					}				}			}						// Analyze the class methods			for (MethodDoc method : classDoc.methods()) {				report.addItem(ReportItem.METHOD, method.qualifiedName() + method.signature());				report.addLocation(ReportItem.METHOD, method.position());				totalNumMethods++;				if (method.commentText().length() != 0)					wordCount = (new StringTokenizer(method.commentText())).countTokens();				else					wordCount = 0;				numMembers++;				numWords += wordCount;				totalNumWords += wordCount;				if (wordCount != 0)					report.appendMessage(ReportItem.METHOD_SUMMARY, "The length of comments is " + wordCount + " words (on/near line " +						method.position().line() + ").");				else {					numZeroComments++;					report.appendMessage(ReportItem.METHOD, "There are no Javadoc comments present (on/near line " +						method.position().line() + ").");				}			}			// Analyze the class' fields			for (FieldDoc field : classDoc.fields()) {				report.addItem(ReportItem.FIELD, field.qualifiedName());				report.addLocation(ReportItem.FIELD, field.position());				if (field.commentText().length() != 0)					wordCount = (new StringTokenizer(field.commentText())).countTokens();				else					wordCount = 0;				numMembers++;				numWords += wordCount;				totalNumWords += wordCount;				totalNumFields++;				if (wordCount != 0)					report.appendMessage(ReportItem.FIELD_SUMMARY, "The length of comments is " + wordCount + " words (on/near line " +						field.position().line() + ").");				else {					numZeroComments++;					report.appendMessage(ReportItem.FIELD, "There are no Javadoc comments present (on/near line " +						field.position().line() + ").");				}			} 			// Generate the report results for the class	 			if (numMembers == 0)				report.appendMessage(ReportItem.CLASS, "There are no class, constructor, " +					"or method comments in the class " + classDoc.qualifiedName() + ".");					 			else {				// Calculate the average length of comments and report on it				ReportItem issueType;				if ((numWords / numMembers) == 0)					issueType = ReportItem.CLASS;				else					issueType = ReportItem.CLASS_SUMMARY;				report.appendMessage(issueType, "The average length of all comments in the class (including all members) is " +					numWords / numMembers + " words.");			}			totalNumComments += numMembers;			report.setFieldsAnalyzed(true);			report.setParamsAnalyzed(false);			report.setThrowsAnalyzed(false);			report.setReturnsAnalyzed(false);		}		// Capture the ending time, just after the termination of the analysis		long endTime = new Date().getTime();		report.addMetric("A total of " + numClasses + " classes were processed.");		report.addMetric("A total of " + totalNumConstructors + " constructors were processed.");		report.addMetric("A total of " + totalNumMethods + " methods were processed.");		report.addMetric("A total of " + totalNumFields + " fields were processed.");		report.addMetric("A total of " + totalNumWords + " words were processed.");		report.addMetric("A total of " + totalNumComments + " class, constructor, method, and field comments were processed.");		report.addMetric("The overall average number of words per comment is " + totalNumWords / totalNumComments + ".");		if (numZeroComments > 0)			report.appendToAmble("postamble", Util.stringWrapAfter(numZeroComments + " location(s) in " +				"your source code are missing comments. Consider commenting all constructors and methods to reduce this " +				"amount. Additionally, if you are receving false results, please be sure you are using the Javadoc " +				"commenting style (i.e. /**  **/).", 80));		report.appendToAmble("preamble", "Javadoc tags (@tag) from constructors and methods are not considered as a part of this analysis.");		report.appendToAmble("preamble", "The score in this module is calculated by determining the ratio of the number of words from comments " +			"to the total number of comments.");		DecimalFormat formatter = new DecimalFormat("0.00");		report.addScore(formatter.format(getGrade()));		report.addTimingString("start time", Long.toString(startTime));		report.addTimingString("end time", Long.toString(endTime));		report.addTimingString("execution time", Long.toString(endTime - startTime));		logger.exit();		return null;	}	/**	  * Sets the grading breakdown for the doclet.	  *	  * @param section Name of the section to set the max grade for	  * @param maxGrade Maximum grade for the section	  */	public void setGradingBreakdown(String section, float maxGrade) {		if (section.equals("Average"))			maxScore = maxGrade;	}	/**	 * Returns the grade for the doclet.	 *	 * @return a float value representing the ratio of number of words	 * from comments to the total number of comments.	 */	public float getGrade() {		float avgWords = 0;				if (totalNumComments == 0) 			return 0.0f;		else			return (float) totalNumWords / totalNumComments;	}	/**	 * Sets a parameter used for doclet grading.	 *	 * @param param Name of the grading parameter	 * @param value Value of the parameter	 */	public void setGradingParameter(String param, String value) {		// Minimum average number of words		if (param.equals("min_ratio"))			minAvgNumWords = Float.parseFloat(value);	}	/**	 * Sets the configuration properties loaded from the config file	 *	 * @param props Properties list	 */	public void setConfigProperties(Properties props) {		// Not needed for this analyzer	}	/**	 * Returns a string representation of this object	 *	 * @return the string name of this analyzer	 */	public String toString() {		return "CommentAvgRatio";	}	/**	 * Returns the string representation of this module's report (JSON format)	 *	 * @return a string value containing the JSON report	 */	public String getJSONReport() {		return report.toString();	}}