/** *  Comment Mentor: A Comment Quality Assessment Tool *  Copyright (C) 2011 The College of New Jersey * *  This program is free software: you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation, either version 3 of the License, or *  (at your option) any later version. * *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. * *  You should have received a copy of the GNU General Public License *  along with this program.  If not, see <http://www.gnu.org/licenses/>. */package comtor.analyzers;import comtor.*;import com.sun.javadoc.*;import java.util.*;import java.text.*;/** * The CommentAvgRatio class is a tool to measure the average length (defined by the number of * words) of comments for all methods and constructors of a class. The "count" of words here, is * number of words the Javadoc comments that (usually) precede the tags (and their comments).  * * @author Joe Brigandi * @author Peter DePasquale */public final class CommentAvgRatio implements ComtorDoclet{	private Properties prop = new Properties();	private float maxScore = 5;	private int totalNumMembers = 0, totalNumWords = 0;	// Default minimum average words per comment.	private float minAvgNumWords = 10;	/**	 * Examine each class and its methods. Calculate the length of each method's comments.	 *	 * @param rootDoc  the root of the documentation tree	 * @return Properties list	 */	public Properties analyze(RootDoc rootDoc) {		// A counter for the classes, used in the properties list		int classID = 0;		DecimalFormat formatter = new DecimalFormat("##0000.000");		prop.setProperty("title", "Comment Average Ratio");		prop.setProperty(formatter.format(-1), "Note that if a class contains no user-defined " +			"constructors, the compiler includes a no-argument, uncommented default constructor. " +			"Javadoc, and thus COMTOR, has no way to eliminate this constructor from this " +			"analysis.");		prop.setProperty(formatter.format(-2), "This module only analyzes the length (in terms of " +			"the number of words) of class, constructor, and method comments.");		// Capture the starting time, just prior to the start of the analysis		long startTime = new Date().getTime();		for (ClassDoc classDoc : rootDoc.classes()) {			double memberID = classID;			int numWords = 0;			int numMembers = 0;			prop.setProperty(formatter.format(classID), "Class: " + classDoc.qualifiedName());						// Analyze the class			prop.setProperty(formatter.format(classID)+".000", "Class comments");			int wordCount = (new StringTokenizer(classDoc.commentText())).countTokens();			if (wordCount == 0)				prop.setProperty(formatter.format(classID)+".001", "None present.");			else {				prop.setProperty(formatter.format(classID)+".001", "The length for the class " +				"comments is " + wordCount + " words.");				numMembers++;				numWords += wordCount;				totalNumWords += wordCount;			}						// Analyze the class constructors			memberID += 0.001;			int comment = 0;			DecimalFormat cmtFmt = new DecimalFormat("000");			prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),				"Constructor comments");			for (ExecutableMemberDoc member : classDoc.constructors()) {				comment++;				String paramList = Util.getParamTypeList(member);				wordCount = (new StringTokenizer(member.commentText())).countTokens();				if (wordCount == 0)					prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),						"No comments present for constructor " + classDoc.qualifiedName() + '(' +						paramList + ')');				else {					prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),						"The length of comments for the constructor " + classDoc.qualifiedName() +						'(' + paramList + ") is " +  wordCount + " words.");					numMembers++;					numWords += wordCount;					totalNumWords += wordCount;				}			}						// Analyze the class methods			memberID += 0.001;			comment = 0;			prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),				"Method comments");			for (ExecutableMemberDoc method : classDoc.methods()) {				comment++;				String paramList = Util.getParamTypeList(method);				wordCount = (new StringTokenizer(method.commentText())).countTokens();				if (wordCount == 0)					prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),						"No comments present for method " + method.qualifiedName() + '(' +						paramList + ')');				else {					prop.setProperty(formatter.format(memberID) + '.' + cmtFmt.format(comment),						"The length of comments for the method " + method.qualifiedName() + '(' +						paramList + ") is " + wordCount + " words.");					numMembers++;					numWords += wordCount;					totalNumWords += wordCount;				}			} 			// Generate the report results for the class	 			memberID += 0.001; 			if (numMembers == 0) 				prop.setProperty(formatter.format(memberID), "There are no class, constructor, " +					"or method comments in the class " + classDoc.qualifiedName() + "."); 			else {				// Calculate the average length of comments and store it in the property list.				prop.setProperty(formatter.format(memberID), "The average length of all comments " + 					"in the class " + classDoc.qualifiedName() + " is " + numWords / numMembers + 					" words.");			}			classID++;			totalNumMembers += numMembers;		}		// Capture the ending time, just after the termination of the analysis		long endTime = new Date().getTime();		prop.setProperty("score", "" + getGrade());		prop.setProperty("metric1", "A total of " + classID + " classes were processed.");		prop.setProperty("metric2", "A total of " + totalNumWords + " words were processed.");		prop.setProperty("metric3", "A total of " + totalNumMembers + " class, method, and " + 			"constructor comments were processed.");		prop.setProperty("metric4", "The overall average number of words per comment is " + 			totalNumWords / totalNumMembers + ".");		prop.setProperty("start time", Long.toString(startTime));		prop.setProperty("end time", Long.toString(endTime));		prop.setProperty("execution time", Long.toString(endTime - startTime));		return prop;	}		/**	  * Sets the grading breakdown for the doclet.	  *	  * @param section Name of the section to set the max grade for	  * @param maxGrade Maximum grade for the section	  */	public void setGradingBreakdown(String section, float maxGrade) {		if (section.equals("Average"))			maxScore = maxGrade;	}	/**	 * Returns the grade for the doclet.	 *	 * @return a float value representing the ratio of correctly spelt words	 * from comments to the total number of works in the comments.	 * @return 	 */	public float getGrade() {		float avgWords = 0;				if (totalNumMembers == 0) 			avgWords = (float) minAvgNumWords;		else			avgWords = (float) totalNumWords / totalNumMembers;		if (avgWords > minAvgNumWords - 0.001)			return maxScore;		else			return (float) 0.0;	}	/**	 * Sets a parameter used for doclet grading.	 *	 * @param param Name of the grading parameter	 * @param value Value of the parameter	 */	public void setGradingParameter(String param, String value) {		// Minimum average number of words		if (param.equals("min_ratio"))			minAvgNumWords = Float.parseFloat(value);	}	/**	 * Sets the configuration properties loaded from the config file	 *	 * @param props Properties list	 */	public void setConfigProperties(Properties props) {		// Not needed for this analyzer	}	/**	 * Returns a string representation of this object	 *	 * @return the string name of this analyzer	 */	public String toString() {		return "CommentAvgRatio";	}}