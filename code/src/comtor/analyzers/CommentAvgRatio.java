/** *  Comment Mentor: A Comment Quality Assessment Tool *  Copyright (C) 2011 The College of New Jersey * *  This program is free software: you can redistribute it and/or modify *  it under the terms of the GNU General Public License as published by *  the Free Software Foundation, either version 3 of the License, or *  (at your option) any later version. * *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. * *  You should have received a copy of the GNU General Public License *  along with this program.  If not, see <http://www.gnu.org/licenses/>. */package comtor.analyzers;import comtor.*;import com.sun.javadoc.*;import java.util.*;import java.text.*;/** * The CommentAvgRatio class is a tool to measure the average length (defined by the number of * words) of comments for all methods and constructors of a class. The "count" of words here, is * number of words the Javadoc comments that (usually) precede the tags (and their comments).  * * @author Joe Brigandi * @author Peter DePasquale */public final class CommentAvgRatio implements ComtorDoclet{	private Properties prop = new Properties();	private float maxScore = 5;	private int numAllMethods = 0, numAllWords = 0;	// Default minimum average words per comment.	private float minAvgNumWords = 10;	/**	 * Examine each class and its methods. Calculate the length of each method's comments.	 *	 * @param rootDoc  the root of the documentation tree	 * @return Properties list	 */	public Properties analyze(RootDoc rootDoc) {		prop.setProperty("title", "Comment Average Ratio");		prop.setProperty("note1", "Note that if a class contains no constructors, the compiler " + 			"include a no-argument, uncommented default constructor. Javadoc, and thus COMTOR, " +			"has no way to eliminate this constructor from this analysis.");		int classID = 0;		DecimalFormat formatter = new DecimalFormat("##0000.000");				// Capture the starting time, just prior to the start of the analysis		long startTime = new Date().getTime();		for (ClassDoc classDoc : rootDoc.classes()) {			prop.setProperty(formatter.format(classID), "Class: " + classDoc.qualifiedName());			int totalWordCount = 0;			int numMethods = 0;			double propID = classID;			// Analyze the constructors in the class			for (ExecutableMemberDoc member : classDoc.constructors()) {				numMethods++;				propID += 0.001;				int wordCount = (new StringTokenizer(member.commentText())).countTokens();				// Store length of comments for the constructor in the property list.				prop.setProperty(formatter.format(propID), "The length of " +					"comments for the constructor " + member.qualifiedName() + " is " + 					wordCount + " words.");				totalWordCount += wordCount;			}						// Analyze the methods in the class			for (ExecutableMemberDoc member : classDoc.methods()) {				numMethods++;				propID += 0.001;				int wordCount = (new StringTokenizer(member.commentText())).countTokens();				// Store length of comments for the method in the property list.				prop.setProperty(formatter.format(propID), "The length of " +					"comments for the method " + member.qualifiedName() + " is " + 					wordCount + " words.");				totalWordCount += wordCount;			}						// Generate the report results						propID += 0.001;			if (numMethods == 0)				prop.setProperty(formatter.format(propID), "There are no methods or constructors " +					"in the class " + classDoc.qualifiedName() + ".");			else {				// Set the points in the map				numAllMethods += numMethods;				numAllWords += totalWordCount;				// Calculate the average length of comments and store it in the property list.				prop.setProperty(formatter.format(propID), "Average length of comments: " + 					totalWordCount / numMethods + " words.");			}			classID++;		}			// Capture the ending time, just after the termination of the analysis		long endTime = new Date().getTime();		prop.setProperty("score", "" + getGrade());		prop.setProperty("metric1", "A total of " + classID + " classes were processed.");		prop.setProperty("metric2", "The overall average number of words per method or " +			"constructor comment is " + numAllWords / numAllMethods + ".");		prop.setProperty("start time", Long.toString(startTime));		prop.setProperty("end time", Long.toString(endTime));		prop.setProperty("execution time", Long.toString(endTime - startTime));		return prop;	}	/**	  * Sets the grading breakdown for the doclet.	  *	  * @param section Name of the section to set the max grade for	  * @param maxGrade Maximum grade for the section	  */	public void setGradingBreakdown(String section, float maxGrade) {		if (section.equals("Average"))			maxScore = maxGrade;	}	/**	 * Returns the grade for the doclet.	 *	 * @return a float value representing the ratio of correctly spelt words	 * from comments to the total number of works in the comments.	 * @return 	 */	public float getGrade() {		float avgWords = 0;				if (numAllMethods == 0) 			avgWords = (float) minAvgNumWords;		else			avgWords = (float) numAllWords / numAllMethods;		if (avgWords > minAvgNumWords - 0.001)			return maxScore;		else			return (float) 0.0;	}	/**	 * Sets a parameter used for doclet grading.	 *	 * @param param Name of the grading parameter	 * @param value Value of the parameter	 */	public void setGradingParameter(String param, String value) {		// Minimum average number of words		if (param.equals("min_ratio"))			minAvgNumWords = Float.parseFloat(value);	}	/**	 * Sets the configuration properties loaded from the config file	 *	 * @param props Properties list	 */	public void setConfigProperties(Properties props) {		// Not needed for this analyzer	}	/**	 * Returns a string representation of this object	 *	 * @return the string name of this analyzer	 */	public String toString() {		return "CommentAvgRatio";	}}